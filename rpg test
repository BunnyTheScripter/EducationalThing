--[[
    Script completely refactored to use the Rayfield UI library.
    - All GUI elements have been replaced with their Rayfield equivalents.
    - Added configuration saving through Rayfield.
    - Player list is now in a dedicated tab and can be refreshed.
    - Aimbot key and FOV circle toggles remain the same.
    - FIXED: Corrected element creation to align with Rayfield (Beta 5) documentation.
    - FIXED: Aimbot is now Hold-to-Use instead of a toggle for better usability.
    - FIXED: Replaced 'table.find' with a custom function to prevent environment conflicts.
    - FIXED: Aimbot key detection now correctly uses UserInputType for mouse buttons.
]]

-- Core Services and Player
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Main Configuration
local CONFIG = {
	ToggleESPKey = Enum.KeyCode.X,
	AimbotKey = Enum.KeyCode.V, -- Aimbot key
	TeleportKey = Enum.KeyCode.Q,
	FlyUpKey = Enum.KeyCode.Space,
	FlyDownKey = Enum.KeyCode.LeftControl,

	AimbotHardLock = false,
	AimbotPrediction = 0.12, MaxAimbotPrediction = 0.5,
	AimbotFOV = 250, MaxAimbotFOV = 1000,
	AimbotSmoothing = 0.15, MaxAimbotSmoothing = 1.0,
	TargetPartName = "Head",
	AimbotTargetParts = {"Head", "UpperTorso", "HumanoidRootPart"},

	HitboxSize = 4, MaxHitboxSize = 50,

	DefaultWalkSpeed = 16, MaxWalkSpeed = 100,
	FlySpeed = 50, MaxFlySpeed = 250,
	TeleportMaxDistance = 200,
}

-- ESP Configuration
local ESP_CONFIG = {
	MaxDistance = 1000,
	TextSize = 14,
	BoxThickness = 1,
	TracerThickness = 1,
	SkeletonThickness = 1.5,
	RainbowSpeed = 1,
	BoxStyles = {"Corner", "Full", "3D"},
	TracerOrigins = {"Bottom", "Top", "Mouse", "Center"},

	ChamsFillColor = Color3.fromRGB(170, 0, 255),
	ChamsOutlineColor = Color3.fromRGB(0, 0, 0),
	ChamsFillTransparency = 0.6,
	ChamsOutlineTransparency = 0,

	EnemyColor = Color3.fromRGB(255, 70, 70),
	AllyColor = Color3.fromRGB(70, 255, 70),
	SkeletonColor = Color3.fromRGB(255, 255, 255),
	RainbowColor = Color3.new(1, 0, 0)
}

-- Script State
local State = {
	IsAimbotActive = false,
	ShowAimbotFOV = true,
	IsFlyEnabled = false,
	IsWallBangEnabled = false,
	HitboxESP = false,

	ESP_Enabled = true,
	TeamCheck = false,
	ShowTeam = false,
	BoxESP = true,
	TracerESP = false,
	SkeletonESP = false,
	ChamsESP = true,
	NameESP = true,
	HealthESP = true,
	DistanceESP = true,
	RainbowMode = false,

	Whitelist = {},
}

-- Local Variables
local espDrawings = {}
local originalHitboxSizes = {}
local aimbotTargetIndex = 1
local flyVelocity = nil
local originalPartProperties = {}
local boxStyleIndex, tracerOriginIndex = 1, 1
local noclipConnection = nil

-- Drawing GUI (for ESP and FOV Circle)
local drawingGui = Instance.new("ScreenGui")
drawingGui.Name = "DrawingGUI"
drawingGui.ResetOnSpawn = false
drawingGui.DisplayOrder = 998
drawingGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local espContainer = Instance.new("Frame", drawingGui)
espContainer.Name = "ESPContainer"
espContainer.Size = UDim2.new(1, 0, 1, 0)
espContainer.BackgroundTransparency = 1

local aimbotFovCircle = Instance.new("Frame", drawingGui)
aimbotFovCircle.Name = "AimbotFovCircle"
aimbotFovCircle.AnchorPoint = Vector2.new(0.5, 0.5)
aimbotFovCircle.BackgroundTransparency = 1
aimbotFovCircle.BorderColor3 = Color3.fromRGB(170, 0, 255)
aimbotFovCircle.BorderSizePixel = 2
aimbotFovCircle.Visible = false
local circleCorner = Instance.new("UICorner", aimbotFovCircle)
circleCorner.CornerRadius = UDim.new(1, 0)


--[[ CORE FUNCTIONS ]]--

local function isPlayerWhitelisted(player)
    if not player then return false end
    for _, whitelistedName in ipairs(State.Whitelist) do
        if whitelistedName == player.Name then
            return true
        end
    end
    return false
end

local function activateGodMode(speaker)
	pcall(function()
		local Cam = workspace.CurrentCamera
		local char, Pos = speaker.Character, Cam.CFrame
		if not char then return end
		local Human = char:FindFirstChildWhichIsA("Humanoid")
		if not Human then return end
		local nHuman = Human:Clone()
		nHuman.Parent = char
		speaker.Character = nil
		nHuman:SetStateEnabled(15, false)
		nHuman:SetStateEnabled(1, false)
		nHuman:SetStateEnabled(0, false)
		nHuman.BreakJointsOnDeath = true
		Human:Destroy()
		speaker.Character = char
		Cam.CameraSubject = nHuman
		task.wait()
		Cam.CFrame = Pos
		nHuman.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
		local Script = char:FindFirstChild("Animate")
		if Script then
			Script.Disabled = true
			task.wait()
			Script.Disabled = false
		end
		nHuman.Health = nHuman.MaxHealth
	end)
end

local function killAllPlayers()
	if game.ReplicatedStorage:FindFirstChild("ACS_Engine") then
		local acsEvent = game.ReplicatedStorage.ACS_Engine:FindFirstChild("Events", true)
		if acsEvent and acsEvent:FindFirstChild("Damage") then
			for _, player in pairs(Players:GetPlayers()) do
				if player ~= LocalPlayer and player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
					acsEvent.Damage:FireServer(player.Character.Humanoid, 100, 100, "Head")
				end
			end
		else print("Could not find ACS Damage Event!") end
	else print("Game doesn't have ACS!") end
end

local function updateWorkspaceCollision(enabled)
	if enabled then
		originalPartProperties = {}
		for _, part in ipairs(Workspace:GetDescendants()) do
			if part:IsA("BasePart") and not part:IsDescendantOf(LocalPlayer.Character) then
				local isPlayerPart = false
				for _, p in ipairs(Players:GetPlayers()) do
					if p ~= LocalPlayer and p.Character and part:IsDescendantOf(p.Character) then isPlayerPart = true; break end
				end
				if not isPlayerPart then
					originalPartProperties[part] = { CanCollide = part.CanCollide, CanQuery = part.CanQuery }
					part.CanCollide, part.CanQuery = false, false
				end
			end
		end
		noclipConnection = Workspace.DescendantAdded:Connect(function(descendant)
			if descendant:IsA("BasePart") and descendant.CanCollide then
				descendant.CanCollide = false
				descendant.CanQuery = false
			end
		end)
	else
		if noclipConnection then
			noclipConnection:Disconnect()
			noclipConnection = nil
		end
		for part, properties in pairs(originalPartProperties) do
			if part and part.Parent then
				part.CanCollide, part.CanQuery = properties.CanCollide, properties.CanQuery
			end
		end
		originalPartProperties = {}
	end
end

local function updateHitboxes()
	for player, data in pairs(originalHitboxSizes) do
		if not State.HitboxESP or not player.Parent or not player.Character or player.Character:FindFirstChildOfClass("Humanoid").Health <= 0 or isPlayerWhitelisted(player) then
			if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
				local hrp = player.Character.HumanoidRootPart
				hrp.Size = data.Size
				hrp.Transparency = data.Transparency
			end
			originalHitboxSizes[player] = nil
		end
	end
	if not State.HitboxESP then return end
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and not isPlayerWhitelisted(player) then
			local char = player.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")
			local humanoid = char and char:FindFirstChildOfClass("Humanoid")
			if hrp and humanoid and humanoid.Health > 0 then
				if not originalHitboxSizes[player] then
					originalHitboxSizes[player] = { Size = hrp.Size, Transparency = hrp.Transparency }
				end
				local newSize = Vector3.new(CONFIG.HitboxSize, CONFIG.HitboxSize, CONFIG.HitboxSize)
				if hrp.Size ~= newSize then
					hrp.Size = newSize
				end
				hrp.Transparency = 0.4
			end
		end
	end
end

local function updateLine(frame, from, to, thickness, color)
	local delta = to - from
	frame.Size = UDim2.fromOffset(delta.Magnitude, thickness)
	frame.Position = UDim2.fromOffset(from.X + delta.X / 2, from.Y + delta.Y / 2)
	frame.Rotation = math.deg(math.atan2(delta.Y, delta.X))
	frame.BackgroundColor3 = color
	frame.Visible = true
end

local BONES = {{"Head","UpperTorso"},{"UpperTorso","LowerTorso"},{"UpperTorso","LeftUpperArm"},{"LeftUpperArm","LeftLowerArm"},{"LeftLowerArm","LeftHand"},{"UpperTorso","RightUpperArm"},{"RightUpperArm","RightLowerArm"},{"RightUpperArm","RightHand"},{"LowerTorso","LeftUpperLeg"},{"LeftUpperLeg","LeftLowerLeg"},{"LeftLowerLeg","LeftFoot"},{"LowerTorso","RightUpperLeg"},{"RightUpperLeg","RightLowerLeg"},{"RightLowerLeg","RightFoot"}}

local function createEspForPlayer(player)
	if espDrawings[player] then return end
	local drawings = {Box={},Skeleton={},Highlight=Instance.new("Highlight"),Tracer=Instance.new("Frame"),Name=Instance.new("TextLabel"),Distance=Instance.new("TextLabel"),HealthBar={Back=Instance.new("Frame"),Front=Instance.new("Frame")}}
	for i = 1, 12 do local line=Instance.new("Frame",espContainer)line.AnchorPoint=Vector2.new(0.5,0.5)line.BorderSizePixel=0 table.insert(drawings.Box,line)end
	for i = 1,#BONES do local line=Instance.new("Frame",espContainer)line.AnchorPoint=Vector2.new(0.5,0.5)line.BorderSizePixel=0 table.insert(drawings.Skeleton,line)end
	drawings.Tracer.Parent=espContainer drawings.Tracer.AnchorPoint=Vector2.new(0.5,0.5)drawings.Tracer.BorderSizePixel=0
	for _,labelType in pairs({"Name","Distance"})do local label=drawings[labelType]label.Parent=espContainer label.BackgroundTransparency=1 label.Font=Enum.Font.SourceSans label.TextStrokeTransparency=0.5 label.TextColor3=Color3.new(1,1,1)end
	drawings.HealthBar.Back.Parent=espContainer drawings.HealthBar.Back.BackgroundColor3=Color3.fromRGB(40,40,40)drawings.HealthBar.Back.BorderSizePixel=0 drawings.HealthBar.Front.Parent=drawings.HealthBar.Back drawings.HealthBar.Front.BorderSizePixel=0
	espDrawings[player] = drawings
end

local function removeEspForPlayer(player)
	if not espDrawings[player] then return end
	for _,collection in pairs(espDrawings[player])do if typeof(collection)=="table"then for _,element in pairs(collection)do element:Destroy()end else collection:Destroy()end end
	espDrawings[player]=nil
end

local function hideDrawingsForPlayer(player)
	local drawings=espDrawings[player]
	if drawings then
		for _,element in pairs(drawings.Box)do element.Visible=false end for _,element in pairs(drawings.Skeleton)do element.Visible=false end drawings.Tracer.Visible,drawings.Name.Visible,drawings.Distance.Visible=false,false,false drawings.HealthBar.Back.Visible=false
		if drawings.Highlight.Parent then drawings.Highlight.Enabled=false end
	end
end

local function updateAllEsp()
	if not State.ESP_Enabled then espContainer.Visible=false for _,player in ipairs(Players:GetPlayers())do if player.Character then local humanoid=player.Character:FindFirstChildOfClass("Humanoid")if humanoid then humanoid.HealthDisplayDistance=100 humanoid.NameDisplayDistance=100 end end hideDrawingsForPlayer(player)end return end
	espContainer.Visible=true if State.RainbowMode then ESP_CONFIG.RainbowColor=Color3.fromHSV((tick()*ESP_CONFIG.RainbowSpeed)%1,1,1)end
	for _,player in ipairs(Players:GetPlayers())do
		local char=player.Character local humanoid=char and char:FindFirstChildOfClass("Humanoid")local hrp=humanoid and char:FindFirstChild("HumanoidRootPart")
		if player~=LocalPlayer and humanoid then humanoid.HealthDisplayDistance=0 humanoid.NameDisplayDistance=0 end
		if player==LocalPlayer or not espDrawings[player] or not hrp or not humanoid or humanoid.Health<=0 then hideDrawingsForPlayer(player)continue end
		local drawings=espDrawings[player]local color=(State.TeamCheck and player.Team==LocalPlayer.Team)and ESP_CONFIG.AllyColor or ESP_CONFIG.EnemyColor if State.RainbowMode then color=ESP_CONFIG.RainbowColor end
		local distance=(hrp.Position-Camera.CFrame.Position).Magnitude local screenPos,onScreen=Camera:WorldToScreenPoint(hrp.Position)
		if not onScreen or distance>ESP_CONFIG.MaxDistance or(State.TeamCheck and not State.ShowTeam and player.Team==LocalPlayer.Team)then hideDrawingsForPlayer(player)continue end
		local size=char:GetExtentsSize()local screenHeight=math.abs((Camera:WorldToScreenPoint((hrp.CFrame*CFrame.new(0,size.Y/2,0)).Position)).Y-(Camera:WorldToScreenPoint((hrp.CFrame*CFrame.new(0,-size.Y/2,0)).Position)).Y)local screenWidth=screenHeight*0.75 local topLeft=Vector2.new(screenPos.X-screenWidth/2,screenPos.Y-screenHeight/2)
		if State.ChamsESP then drawings.Highlight.Parent=char drawings.Highlight.Enabled=true drawings.Highlight.FillColor=ESP_CONFIG.ChamsFillColor drawings.Highlight.OutlineColor=ESP_CONFIG.ChamsOutlineColor drawings.Highlight.FillTransparency=ESP_CONFIG.ChamsFillTransparency drawings.Highlight.OutlineTransparency=ESP_CONFIG.ChamsOutlineTransparency drawings.Highlight.DepthMode=Enum.HighlightDepthMode.AlwaysOnTop elseif drawings.Highlight.Parent then drawings.Highlight.Enabled=false end
		drawings.Name.Visible=State.NameESP drawings.Distance.Visible=State.DistanceESP
		if State.NameESP or State.DistanceESP then local infoText=""if State.NameESP then infoText=player.DisplayName end if State.DistanceESP then infoText=infoText.." ["..math.floor(distance).."m]"end drawings.Name.Text=infoText drawings.Name.TextSize=ESP_CONFIG.TextSize drawings.Name.Position=UDim2.fromOffset(topLeft.X+screenWidth/2,topLeft.Y-ESP_CONFIG.TextSize-2)drawings.Name.TextColor3=color end
		drawings.HealthBar.Back.Visible=State.HealthESP
		if State.HealthESP then local healthPercent=humanoid.Health/humanoid.MaxHealth drawings.HealthBar.Back.Position=UDim2.fromOffset(topLeft.X-7,topLeft.Y)drawings.HealthBar.Back.Size=UDim2.fromOffset(4,screenHeight)drawings.HealthBar.Front.Size=UDim2.new(1,0,healthPercent,0)drawings.HealthBar.Front.Position=UDim2.new(0,0,1-healthPercent,0)drawings.HealthBar.Front.BackgroundColor3=Color3.fromHSV(0.33*healthPercent,1,1)end
		drawings.Tracer.Visible=State.TracerESP
		if State.TracerESP then local origin local originStyle=ESP_CONFIG.TracerOrigins[tracerOriginIndex]if originStyle=="Bottom"then origin=Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y)elseif originStyle=="Top"then origin=Vector2.new(Camera.ViewportSize.X/2,0)elseif originStyle=="Mouse"then origin=UserInputService:GetMouseLocation()else origin=Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y/2)end updateLine(drawings.Tracer,origin,Vector2.new(screenPos.X,screenPos.Y),ESP_CONFIG.TracerThickness,color)end
		for i,line in ipairs(drawings.Box)do line.Visible=false end
		if State.BoxESP then local boxStyle=ESP_CONFIG.BoxStyles[boxStyleIndex]if boxStyle=="3D"then local corners={hrp.CFrame*CFrame.new(-size.X/2,-size.Y/2,-size.Z/2),hrp.CFrame*CFrame.new(size.X/2,-size.Y/2,-size.Z/2),hrp.CFrame*CFrame.new(size.X/2,size.Y/2,-size.Z/2),hrp.CFrame*CFrame.new(-size.X/2,size.Y/2,-size.Z/2),hrp.CFrame*CFrame.new(-size.X/2,-size.Y/2,size.Z/2),hrp.CFrame*CFrame.new(size.X/2,-size.Y/2,size.Z/2),hrp.CFrame*CFrame.new(size.X/2,size.Y/2,size.Z/2),hrp.CFrame*CFrame.new(-size.X/2,size.Y/2,size.Z/2)}local points,valid={},true for i,corner in ipairs(corners)do local p,v=Camera:WorldToScreenPoint(corner.Position)if not v then valid=false;break end points[i]=Vector2.new(p.X,p.Y)end if valid then local connections={1,2,2,3,3,4,4,1,5,6,6,7,7,8,8,5,1,5,2,6,3,7,4,8}for i=1,12 do updateLine(drawings.Box[i],points[connections[i*2-1]],points[connections[i*2]],ESP_CONFIG.BoxThickness,color)end end elseif boxStyle=="Corner"then local cornerLength=math.min(screenWidth,screenHeight)*0.2 local corners={{topLeft,topLeft+Vector2.new(cornerLength,0)},{topLeft,topLeft+Vector2.new(0,cornerLength)},{topLeft+Vector2.new(screenWidth,0),topLeft+Vector2.new(screenWidth-cornerLength,0)},{topLeft+Vector2.new(screenWidth,0),topLeft+Vector2.new(screenWidth,cornerLength)},{topLeft+Vector2.new(0,screenHeight),topLeft+Vector2.new(cornerLength,screenHeight)},{topLeft+Vector2.new(0,screenHeight),topLeft+Vector2.new(0,screenHeight-cornerLength)},{topLeft+Vector2.new(screenWidth,screenHeight),topLeft+Vector2.new(screenWidth-cornerLength,screenHeight)},{topLeft+Vector2.new(screenWidth,screenHeight),topLeft+Vector2.new(screenWidth,screenHeight-cornerLength)}}for i,data in ipairs(corners)do updateLine(drawings.Box[i],data[1],data[2],ESP_CONFIG.BoxThickness,color)end else local points={topLeft,topLeft+Vector2.new(screenWidth,0),topLeft+Vector2.new(screenWidth,screenHeight),topLeft+Vector2.new(0,screenHeight)}for i=1,4 do updateLine(drawings.Box[i],points[i],points[i%4+1],ESP_CONFIG.BoxThickness,color)end end end
		for i,line in ipairs(drawings.Skeleton)do line.Visible=false end
		if State.SkeletonESP then local parts={}for _,partName in ipairs({"Head","UpperTorso","LowerTorso","LeftUpperArm","LeftLowerArm","LeftHand","RightUpperArm","RightLowerArm","RightHand","LeftUpperLeg","LeftLowerLeg","LeftFoot","RightUpperLeg","RightLowerLeg","RightFoot"})do parts[partName]=char:FindFirstChild(partName)end for i,bone in ipairs(BONES)do local p1,p2=parts[bone[1]],parts[bone[2]]if p1 and p2 then local s1,v1=Camera:WorldToScreenPoint(p1.Position)local s2,v2=Camera:WorldToScreenPoint(p2.Position)if v1 and v2 then updateLine(drawings.Skeleton[i],Vector2.new(s1.X,s1.Y),Vector2.new(s2.X,s2.Y),ESP_CONFIG.SkeletonThickness,ESP_CONFIG.SkeletonColor)end end end end
	end
end

local function updateAimbotFOV()
	aimbotFovCircle.Visible = State.ShowAimbotFOV and State.IsAimbotActive
	if aimbotFovCircle.Visible then
		local fovSize = CONFIG.AimbotFOV * 2
		aimbotFovCircle.Position = UDim2.fromOffset(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
		aimbotFovCircle.Size = UDim2.fromOffset(fovSize, fovSize)
	end
end

local function getAimbotTarget()
	local bestTarget, min3DDistance = nil, math.huge
	local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and not isPlayerWhitelisted(player) and player.Character and player.Character:FindFirstChild(CONFIG.TargetPartName) and player.Character:FindFirstChildOfClass("Humanoid") and player.Character.Humanoid.Health > 0 then
			local targetPart = player.Character[CONFIG.TargetPartName]
			local screenPosition, onScreen = Camera:WorldToScreenPoint(targetPart.Position)
			if onScreen and (Vector2.new(screenPosition.X, screenPosition.Y) - screenCenter).Magnitude < CONFIG.AimbotFOV then
				local distance3D = (targetPart.Position - Camera.CFrame.Position).Magnitude
				if distance3D < min3DDistance then
					min3DDistance = distance3D
					bestTarget = targetPart
				end
			end
		end
	end
	return bestTarget
end

local function updateAimbot()
	if not State.IsAimbotActive then return end
	local target = getAimbotTarget()
	if target then
		local predictedPosition = target.Position + (target.AssemblyLinearVelocity * CONFIG.AimbotPrediction)
		local newCFrame = CFrame.new(Camera.CFrame.Position, predictedPosition)
		if CONFIG.AimbotHardLock then
			Camera.CFrame = newCFrame
		else
			Camera.CFrame = Camera.CFrame:Lerp(newCFrame, CONFIG.AimbotSmoothing)
		end
	end
end

local function updateFly()
	local char = LocalPlayer.Character
	if not State.IsFlyEnabled or not char or not char:FindFirstChild("HumanoidRootPart") then
		if flyVelocity then flyVelocity:Destroy(); flyVelocity = nil end
		return
	end
	local hrp = char.HumanoidRootPart
	if not flyVelocity then
		flyVelocity = Instance.new("LinearVelocity", hrp)
		flyVelocity.MaxForce = math.huge
		flyVelocity.Attachment0 = hrp:FindFirstChildWhichIsA("Attachment") or Instance.new("Attachment", hrp)
		flyVelocity.RelativeTo = Enum.ActuatorRelativeTo.World
	end
	local moveVector = Vector3.new()
	if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVector += Camera.CFrame.LookVector end
	if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVector -= Camera.CFrame.LookVector end
	if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVector += Camera.CFrame.RightVector end
	if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVector -= Camera.CFrame.RightVector end
	if UserInputService:IsKeyDown(CONFIG.FlyUpKey) then moveVector += Vector3.new(0, 1, 0) end
	if UserInputService:IsKeyDown(CONFIG.FlyDownKey) then moveVector -= Vector3.new(0, 1, 0) end
	flyVelocity.VectorVelocity = moveVector.Magnitude > 0 and moveVector.Unit * CONFIG.FlySpeed or Vector3.zero
end

local function teleportToCursor()
	if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
	local mouseLocation = UserInputService:GetMouseLocation()
	local unitRay = Camera:ViewportPointToRay(mouseLocation.X, mouseLocation.Y)
	local rayParams = RaycastParams.new()
	rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
	rayParams.FilterType = Enum.RaycastFilterType.Exclude
	local result = Workspace:Raycast(unitRay.Origin, unitRay.Direction * CONFIG.TeleportMaxDistance, rayParams)
	local targetPos = result and result.Position or (unitRay.Origin + unitRay.Direction * CONFIG.TeleportMaxDistance)
	LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos)
end

--[[ RAYFIELD UI SETUP ]]--

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
	Name = "mooncat v5.0",
	LoadingTitle = "mooncat Interface Suite",
	LoadingSubtitle = "by zen",
	ConfigurationSaving = {
		Enabled = true,
		FolderName = "mooncat_v5",
		FileName = "settings"
	}
})

-- ESP Tab
local ESP_Tab = Window:CreateTab("ESP", 4483362458)
local ESP_Section = ESP_Tab:CreateSection("Visuals")

local espToggle = ESP_Tab:CreateToggle({
	Name = "Enable ESP",
	CurrentValue = State.ESP_Enabled,
	Flag = "ESP_Enabled",
	Callback = function(Value)
		State.ESP_Enabled = Value
	end,
})

ESP_Tab:CreateToggle({ Name = "Box ESP", CurrentValue = State.BoxESP, Flag = "BoxESP", Callback = function(v) State.BoxESP = v end })
ESP_Tab:CreateDropdown({
	Name = "Box Style",
	Options = ESP_CONFIG.BoxStyles,
	CurrentOption = {ESP_CONFIG.BoxStyles[boxStyleIndex]}, -- Fixed to be a table
	Flag = "BoxStyle",
	Callback = function(Option) -- Option is a table
		for i, v in ipairs(ESP_CONFIG.BoxStyles) do if v == Option[1] then boxStyleIndex = i; break end end
	end,
})

ESP_Tab:CreateToggle({ Name = "Tracer ESP", CurrentValue = State.TracerESP, Flag = "TracerESP", Callback = function(v) State.TracerESP = v end })
ESP_Tab:CreateDropdown({
	Name = "Tracer Origin",
	Options = ESP_CONFIG.TracerOrigins,
	CurrentOption = {ESP_CONFIG.TracerOrigins[tracerOriginIndex]}, -- Fixed to be a table
	Flag = "TracerOrigin",
	Callback = function(Option) -- Option is a table
		for i, v in ipairs(ESP_CONFIG.TracerOrigins) do if v == Option[1] then tracerOriginIndex = i; break end end
	end,
})

ESP_Tab:CreateToggle({ Name = "Name ESP", CurrentValue = State.NameESP, Flag = "NameESP", Callback = function(v) State.NameESP = v end })
ESP_Tab:CreateToggle({ Name = "Health ESP", CurrentValue = State.HealthESP, Flag = "HealthESP", Callback = function(v) State.HealthESP = v end })
ESP_Tab:CreateToggle({ Name = "Distance ESP", CurrentValue = State.DistanceESP, Flag = "DistanceESP", Callback = function(v) State.DistanceESP = v end })
ESP_Tab:CreateToggle({ Name = "Skeleton ESP", CurrentValue = State.SkeletonESP, Flag = "SkeletonESP", Callback = function(v) State.SkeletonESP = v end })
ESP_Tab:CreateToggle({ Name = "Chams ESP", CurrentValue = State.ChamsESP, Flag = "ChamsESP", Callback = function(v) State.ChamsESP = v end })
ESP_Tab:CreateToggle({ Name = "Rainbow Mode", CurrentValue = State.RainbowMode, Flag = "RainbowMode", Callback = function(v) State.RainbowMode = v end })

ESP_Tab:CreateSlider({
	Name = "Max Distance",
	Range = {0, 5000},
	Increment = 50,
	Suffix = "m",
	CurrentValue = ESP_CONFIG.MaxDistance,
	Flag = "MaxDistance",
	Callback = function(Value) ESP_CONFIG.MaxDistance = Value end
})

-- Combat Tab
local Combat_Tab = Window:CreateTab("Combat", 4483362458)
local Combat_Section = Combat_Tab:CreateSection("Aimbot")

Combat_Tab:CreateToggle({
	Name = "Show Aimbot FOV",
	CurrentValue = State.ShowAimbotFOV,
	Flag = "ShowAimbotFOV",
	Callback = function(Value) State.ShowAimbotFOV = Value end
})

-- ## THIS IS THE MAIN FIX ##
Combat_Tab:CreateDropdown({
	Name = "Aimbot Target",
	Options = CONFIG.AimbotTargetParts,
	CurrentOption = {CONFIG.TargetPartName}, -- `CurrentOption` must be a table
	Flag = "AimbotTargetPart",
	Callback = function(Option)
		CONFIG.TargetPartName = Option[1] -- The callback gives a table, so we take the first item
	end,
})

Combat_Tab:CreateSlider({ Name = "Aimbot FOV", Range = {0, CONFIG.MaxAimbotFOV}, Increment = 10, Suffix = "px", CurrentValue = CONFIG.AimbotFOV, Flag = "AimbotFOV", Callback = function(v) CONFIG.AimbotFOV = v end})
Combat_Tab:CreateSlider({ Name = "Aimbot Prediction", Range = {0, CONFIG.MaxAimbotPrediction}, Increment = 0.01, Suffix = "s", CurrentValue = CONFIG.AimbotPrediction, Flag = "AimbotPrediction", Callback = function(v) CONFIG.AimbotPrediction = v end})
Combat_Tab:CreateSlider({ Name = "Aimbot Smoothing", Range = {0, CONFIG.MaxAimbotSmoothing}, Increment = 0.05, Suffix = "", CurrentValue = CONFIG.AimbotSmoothing, Flag = "AimbotSmoothing", Callback = function(v) CONFIG.AimbotSmoothing = v end})

Combat_Tab:CreateSection("Misc Combat")

Combat_Tab:CreateToggle({
	Name = "Hitbox Expander",
	CurrentValue = State.HitboxESP,
	Flag = "HitboxESP",
	Callback = function(v) State.HitboxESP = v end,
})
Combat_Tab:CreateSlider({ Name = "Hitbox Size", Range = {0, CONFIG.MaxHitboxSize}, Increment = 1, CurrentValue = CONFIG.HitboxSize, Flag = "HitboxSize", Callback = function(v) CONFIG.HitboxSize = v end})

Combat_Tab:CreateButton({ Name = "God Mode", Callback = function() activateGodMode(LocalPlayer) end})
Combat_Tab:CreateButton({ Name = "Kill All (ACS)", Callback = killAllPlayers })
Combat_Tab:CreateButton({
	Name = "Infinite RPG Ammo",
	Callback = function()
		pcall(function()
			local ammo = game:GetService("ReplicatedStorage").Configurations.ACS_Guns.RPG.Ammo
			local parent = ammo.Parent
			local name = ammo.Name
			ammo:Destroy()
			local newAmmo = Instance.new("NumberValue", parent)
			newAmmo.Name = name
			newAmmo.Value = 9e9
		end)
	end,
})

-- Movement Tab
local Movement_Tab = Window:CreateTab("Movement", 4483362458)
local Movement_Section = Movement_Tab:CreateSection("Movement")

Movement_Tab:CreateToggle({
	Name = "Fly",
	CurrentValue = State.IsFlyEnabled,
	Flag = "FlyEnabled",
	Callback = function(v)
		State.IsFlyEnabled = v
		if not v and flyVelocity then flyVelocity:Destroy(); flyVelocity = nil end
	end,
})

Movement_Tab:CreateToggle({
	Name = "WallBang (Noclip)",
	CurrentValue = State.IsWallBangEnabled,
	Flag = "WallBangEnabled",
	Callback = function(v)
		State.IsWallBangEnabled = v
		updateWorkspaceCollision(v)
	end,
})

Movement_Tab:CreateSlider({
	Name = "WalkSpeed",
	Range = {16, CONFIG.MaxWalkSpeed},
	Increment = 1,
	CurrentValue = CONFIG.DefaultWalkSpeed,
	Flag = "WalkSpeed",
	Callback = function(v)
		CONFIG.DefaultWalkSpeed = v
		if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
			LocalPlayer.Character.Humanoid.WalkSpeed = v
		end
	end,
})
Movement_Tab:CreateSlider({ Name = "Fly Speed", Range = {0, CONFIG.MaxFlySpeed}, Increment = 10, CurrentValue = CONFIG.FlySpeed, Flag = "FlySpeed", Callback = function(v) CONFIG.FlySpeed = v end})

-- Players Tab
local Players_Tab = Window:CreateTab("Players", 4483362458)
Players_Tab:CreateSection("Player List - Refresh to update")

Players_Tab:CreateButton({
	Name = "Refresh Player List",
	Callback = function()
		Players_Tab:CreateSection("Players - " .. os.date("%X"))
		
		for _, player in ipairs(Players:GetPlayers()) do
			if player ~= LocalPlayer then
				Players_Tab:CreateLabel(player.Name)

				Players_Tab:CreateButton({
					Name = "Teleport",
					Callback = function()
						if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
							LocalPlayer.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame
						end
					end
				})
				
				local isWhitelisted = isPlayerWhitelisted(player)
				Players_Tab:CreateToggle({
					Name = "Whitelist",
					CurrentValue = isWhitelisted,
					Callback = function(isNowWhitelisted)
						local index
						for i, name in ipairs(State.Whitelist) do
							if name == player.Name then
								index = i
								break
							end
						end

						if isNowWhitelisted and not index then
							table.insert(State.Whitelist, player.Name)
						elseif not isNowWhitelisted and index then
							table.remove(State.Whitelist, index)
						end
					end
				})
				Players_Tab:CreateParagraph({Title = "", Content = string.rep("-", 40)})
			end
		end
	end
})


--[[ SCRIPT INITIALIZATION AND LOOPS ]]--

local function onCharacterAdded(character)
	task.wait(0.1)
	if not character or not character.Parent then return end
	local humanoid = character:WaitForChild("Humanoid")
	humanoid.WalkSpeed = CONFIG.DefaultWalkSpeed
end

local function onPlayerAdded(player)
	if player ~= LocalPlayer then createEspForPlayer(player) end
end

local function onPlayerRemoving(player)
	removeEspForPlayer(player)
	if originalHitboxSizes[player] then originalHitboxSizes[player] = nil end
end

local function onInputBegan(input, gameProcessed)
	if gameProcessed then return end

    -- ## THIS IS THE FIX ##
	-- Check for both KeyCode (keyboard) and UserInputType (mouse buttons)
	if input.KeyCode == CONFIG.AimbotKey or input.UserInputType == CONFIG.AimbotKey then
		State.IsAimbotActive = true
	end
    
	if input.KeyCode == CONFIG.TeleportKey then
		teleportToCursor()
	end
	if input.KeyCode == CONFIG.ToggleESPKey then
		State.ESP_Enabled = not State.ESP_Enabled
		espToggle:Set(State.ESP_Enabled)
	end
end

local function onInputEnded(input, gameProcessed)
    if gameProcessed then return end

    -- ## THIS IS THE FIX ##
    -- Check for both KeyCode (keyboard) and UserInputType (mouse buttons)
    if input.KeyCode == CONFIG.AimbotKey or input.UserInputType == CONFIG.AimbotKey then
        State.IsAimbotActive = false
    end
end


-- Connect events
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)
UserInputService.InputBegan:Connect(onInputBegan)
UserInputService.InputEnded:Connect(onInputEnded)
if LocalPlayer.Character then onCharacterAdded(LocalPlayer.Character) end
LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

-- Initialize for existing players
for _, player in ipairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end

-- Main render loop
RunService.RenderStepped:Connect(function()
	updateAllEsp()
	updateAimbot()
	updateAimbotFOV()
	updateFly()
	updateHitboxes()
end)

-- Load saved settings
Rayfield:LoadConfiguration()

-- Updated notification to use Lucide Icons
Rayfield:Notify({
    Title = "mooncat v5.0 Loaded",
    Content = "Press RightShift to toggle the menu.",
    Image = "cat", -- Using a Lucide Icon string instead of an ID
    Duration = 5
})

print([[
 __  __                      ____      _
|  \/  | ___   ___  _ __    / ___|__ _| |_
| |\/| |/ _ \ / _ \| '_ \  | |   / _` | __|
| |  | | (_) | (_) | | | | | |__| (_| | |_
|_|  |_|\___/ \___/|_| |_|  \____\__,_|\__|

mooncat v5.0 (Client-Side) Loaded.
]])
