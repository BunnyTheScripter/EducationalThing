-- [+] DEBUG CONFIGURATION [+]
local debug = true -- Set to true to see detailed logs in the console

-- [+] SERVICES [+]
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- [+] LOCAL PLAYER & CAMERA [+]
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- [+] DEBUG LOGGER [+]
local function log(prefix, message)
	if debug then
		print(prefix .. " " .. message)
	end
end

log("[‚úÖ]", "Script services and logger initialized.")

-- [+] CORE CONFIG [+]
local CONFIG = {
	ToggleGUIKey = Enum.KeyCode.RightShift,
	ToggleESPKey = Enum.KeyCode.X,
	AimbotKey = Enum.KeyCode.E,
	TeleportKey = Enum.KeyCode.Q,
	FlyUpKey = Enum.KeyCode.Space,
	FlyDownKey = Enum.KeyCode.LeftControl,

	AimbotHardLock = false,
	AimbotPrediction = 0.12, MaxAimbotPrediction = 0.5,
	AimbotFOV = 250, MaxAimbotFOV = 1000,
	AimbotSmoothing = 0.15, MaxAimbotSmoothing = 1.0,
	TargetPartName = "Head",
	AimbotTargetParts = {"Head", "UpperTorso", "HumanoidRootPart"},

	HitboxSize = 4, MaxHitboxSize = 50,

	DefaultWalkSpeed = 16, MaxWalkSpeed = 100,
	FlySpeed = 50, MaxFlySpeed = 250,
	TeleportMaxDistance = 200,
}

-- [+] ESP CONFIG [+]
local ESP_CONFIG = {
	MaxDistance = 1000,
	TextSize = 14,
	BoxThickness = 1,
	TracerThickness = 1,
	SkeletonThickness = 1.5,
	RainbowSpeed = 1,
	BoxStyles = {"Corner", "Full", "3D"},
	TracerOrigins = {"Bottom", "Top", "Mouse", "Center"},

	ChamsFillColor = Color3.fromRGB(170, 0, 255),
	ChamsOutlineColor = Color3.fromRGB(0, 0, 0),
	ChamsFillTransparency = 0.6,
	ChamsOutlineTransparency = 0,

	EnemyColor = Color3.fromRGB(255, 70, 70),
	AllyColor = Color3.fromRGB(70, 255, 70),
	SkeletonColor = Color3.fromRGB(255, 255, 255),
	RainbowColor = Color3.new(1, 0, 0)
}

-- [+] SCRIPT STATE [+]
local State = {
	IsAimbotActive = false,
	IsFlyEnabled = false,
	IsWallBangEnabled = false,
	HitboxESP = false,

	ESP_Enabled = true,
	TeamCheck = false,
	ShowTeam = false,
	BoxESP = true,
	TracerESP = false,
	SkeletonESP = false,
	ChamsESP = true,
	NameESP = true,
	HealthESP = true,
	DistanceESP = true,
	RainbowMode = false,
}

-- [+] RPG MODIFIER LOGIC (FIXED) [+]
local function modifyRpgSettings()
	log("[üîç]", "Attempting to modify RPG settings via source manipulation...")
	local success, err = pcall(function()
		local configurations = ReplicatedStorage:WaitForChild("Configurations", 5)
		if not configurations then error("Configurations folder not found.") end
		
		local acsGuns = configurations:WaitForChild("ACS_Guns", 5)
		if not acsGuns then error("ACS_Guns folder not found.") end

		local rpgFolder = acsGuns:WaitForChild("RPG", 5)
		if not rpgFolder then error("RPG folder not found in ACS_Guns.") end
		
		local settingsModule = rpgFolder:WaitForChild("Settings", 5)
		if not settingsModule or not settingsModule:IsA("ModuleScript") then error("Settings module not found or is not a ModuleScript.") end

		log("[‚úÖ]", "Found RPG settings module at: " .. settingsModule:GetFullName())

		local source = settingsModule.Source
		if not source or #source < 10 then error("Could not read module source.") end
		
		log("[üîç]", "Original source read. Applying modifications...")
		
		-- Use string.gsub to replace values without breaking the code structure
		source = source:gsub("(Ammo = )%d+", "%1 99999")
		source = source:gsub("(FireRate = )%d+", "%1 1000")
		source = source:gsub("(BDrop = )[%d%.]+", "%1 0")
		source = source:gsub("(BSpeed = )%d+", "%1 5000")
		source = source:gsub('(Mode = )"RPG"', '%1"Auto"')
		source = source:gsub("(Auto = )false", "%1 true")
		source = source:gsub("(VRecoil = ){[^}]+}", "%1{0, 0}")
		source = source:gsub("(HRecoil = ){[^}]+}", "%1{0, 0}")
		source = source:gsub("(RecoilPunch = )[%d%.]+", "%1 0")
		source = source:gsub("(MinSpread = )[%d%.]+", "%1 0")
		source = source:gsub("(MaxSpread = )[%d%.]+", "%1 0")

		-- Overwrite the module's source with our modified version
		settingsModule.Source = source
		
		log("[‚úÖ]", "Overpowered RPG settings have been written to the module's source successfully!")
		log("[‚ÑπÔ∏è]", "Re-equip the RPG for changes to take effect.")
	end)

	if not success then
		log("[‚ùå]", "Failed to modify RPG settings: " .. tostring(err))
	end
end


-- [-] SCRIPT CORE (GUI, ESP, AIMBOT, ETC) - NO CHANGES BELOW THIS LINE EXCEPT FOR GUI CREATION [-]

local uiElements = {}
local espDrawings = {}
local originalHitboxSizes = {}
local espContainer
local aimbotFovCircle
local aimbotTargetIndex = 1
local flyVelocity = nil
local originalPartProperties = {}
local boxStyleIndex, tracerOriginIndex = 1, 1

local function killAllPlayers()
	log("[üîç]", "Attempting to use Kill All (ACS)...")
	local acsEngine = ReplicatedStorage:FindFirstChild("ACS_Engine")
	if acsEngine then
		local acsEvent = acsEngine:FindFirstChild("Events", true)
		if acsEvent and acsEvent:FindFirstChild("Damage") then
			local count = 0
			for _, player in pairs(Players:GetPlayers()) do
				if player ~= LocalPlayer and player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
					acsEvent.Damage:FireServer(player.Character.Humanoid, 100, 100, "Head")
					count = count + 1
				end
			end
			log("[‚úÖ]", "Fired Kill All event for " .. count .. " players.")
		else log("[‚ùå]", "Could not find ACS Damage Event!") end
	else log("[‚ùå]", "Game doesn't have ACS Engine!") end
end

local function updateWorkspaceCollision(enabled)
	if enabled then
		originalPartProperties = {}
		for _, part in ipairs(Workspace:GetDescendants()) do
			if part:IsA("BasePart") and not part:IsDescendantOf(LocalPlayer.Character) then
				local isPlayerPart = false
				for _, p in ipairs(Players:GetPlayers()) do
					if p ~= LocalPlayer and p.Character and part:IsDescendantOf(p.Character) then isPlayerPart = true; break end
				end
				if not isPlayerPart then
					originalPartProperties[part] = { CanCollide = part.CanCollide, CanQuery = part.CanQuery }
					part.CanCollide, part.CanQuery = false, false
				end
			end
		end
		log("[‚úÖ]", "WallBang (Noclip) enabled.")
	else
		for part, properties in pairs(originalPartProperties) do
			if part and part.Parent then
				part.CanCollide, part.CanQuery = properties.CanCollide, properties.CanQuery
			end
		end
		originalPartProperties = {}
		log("[‚úÖ]", "WallBang (Noclip) disabled.")
	end
end

local function updateHitboxes()
	if not State.HitboxESP then
		if next(originalHitboxSizes) then
			for player, data in pairs(originalHitboxSizes) do
				if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
					local hrp = player.Character.HumanoidRootPart
					hrp.Size = data.Size
					hrp.Transparency = data.Transparency
				end
			end
			originalHitboxSizes = {}
		end
		return
	end

	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			local char = player.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")
			local humanoid = char and char:FindFirstChildOfClass("Humanoid")

			if hrp and humanoid and humanoid.Health > 0 then
				if not originalHitboxSizes[player] then
					originalHitboxSizes[player] = {
						Size = hrp.Size,
						Transparency = hrp.Transparency
					}
				end

				local newSize = Vector3.new(CONFIG.HitboxSize, CONFIG.HitboxSize, CONFIG.HitboxSize)
				if hrp.Size ~= newSize then
					hrp.Size = newSize
				end
				hrp.Transparency = 0.4
			end
		end
	end
end

local function updateLine(frame, from, to, thickness, color)
	local delta = to - from
	frame.Size = UDim2.fromOffset(delta.Magnitude, thickness)
	frame.Position = UDim2.fromOffset(from.X + delta.X / 2, from.Y + delta.Y / 2)
	frame.Rotation = math.deg(math.atan2(delta.Y, delta.X))
	frame.BackgroundColor3 = color
	frame.Visible = true
end

local BONES = {
	{ "Head", "UpperTorso" },
	{ "UpperTorso", "LowerTorso" },
	{ "UpperTorso", "LeftUpperArm" }, { "LeftUpperArm", "LeftLowerArm" }, { "LeftLowerArm", "LeftHand" },
	{ "UpperTorso", "RightUpperArm" }, { "RightUpperArm", "RightLowerArm" }, { "RightLowerArm", "RightHand" },
	{ "LowerTorso", "LeftUpperLeg" }, { "LeftUpperLeg", "LeftLowerLeg" }, { "LeftLowerLeg", "LeftFoot" },
	{ "LowerTorso", "RightUpperLeg" }, { "RightUpperLeg", "RightLowerLeg" }, { "RightLowerLeg", "RightFoot" },
}

local function createEspForPlayer(player)
	if espDrawings[player] then return end

	local drawings = {
		Box = {}, Skeleton = {},
		Highlight = (Instance.new("Highlight")),
		Tracer = (Instance.new("Frame")),
		Name = (Instance.new("TextLabel")),
		Distance = (Instance.new("TextLabel")),
		HealthBar = {
			Back = Instance.new("Frame"),
			Front = Instance.new("Frame")
		}
	}

	for i = 1, 12 do
		local line = Instance.new("Frame", espContainer)
		line.AnchorPoint = Vector2.new(0.5, 0.5)
		line.BorderSizePixel = 0
		table.insert(drawings.Box, line)
	end

	for i = 1, #BONES do
		local line = Instance.new("Frame", espContainer)
		line.AnchorPoint = Vector2.new(0.5, 0.5)
		line.BorderSizePixel = 0
		table.insert(drawings.Skeleton, line)
	end

	drawings.Tracer.Parent = espContainer
	drawings.Tracer.AnchorPoint = Vector2.new(0.5, 0.5)
	drawings.Tracer.BorderSizePixel = 0

	for _, labelType in pairs({"Name", "Distance"}) do
		local label = drawings[labelType]
		label.Parent = espContainer
		label.BackgroundTransparency = 1
		label.Font = Enum.Font.SourceSans
		label.TextStrokeTransparency = 0.5
		label.TextColor3 = Color3.new(1, 1, 1)
	end

	drawings.HealthBar.Back.Parent = espContainer
	drawings.HealthBar.Back.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	drawings.HealthBar.Back.BorderSizePixel = 0
	drawings.HealthBar.Front.Parent = drawings.HealthBar.Back
	drawings.HealthBar.Front.BorderSizePixel = 0

	espDrawings[player] = drawings
end

local function removeEspForPlayer(player)
	if not espDrawings[player] then return end
	for _, collection in pairs(espDrawings[player]) do
		if typeof(collection) == "table" then
			for _, element in pairs(collection) do element:Destroy() end
		else
			collection:Destroy()
		end
	end
	espDrawings[player] = nil
end

local function hideDrawingsForPlayer(player)
	local drawings = espDrawings[player]
	if drawings then
		for _, element in pairs(drawings.Box) do element.Visible = false end
		for _, element in pairs(drawings.Skeleton) do element.Visible = false end
		drawings.Tracer.Visible, drawings.Name.Visible, drawings.Distance.Visible = false, false, false
		drawings.HealthBar.Back.Visible = false
		if drawings.Highlight.Parent then drawings.Highlight.Enabled = false end
	end
end

local function updateAllEsp()
	if not State.ESP_Enabled then
		if espContainer.Visible then espContainer.Visible = false end
		return
	end

	if not espContainer.Visible then espContainer.Visible = true end
	if State.RainbowMode then ESP_CONFIG.RainbowColor = Color3.fromHSV((tick() * ESP_CONFIG.RainbowSpeed) % 1, 1, 1) end

	for _, player in ipairs(Players:GetPlayers()) do
		local char = player.Character
		local humanoid = char and char:FindFirstChildOfClass("Humanoid")
		local hrp = humanoid and char:FindFirstChild("HumanoidRootPart")

		if player ~= LocalPlayer and humanoid then
			humanoid.HealthDisplayDistance = 0
			humanoid.NameDisplayDistance = 0
		end

		if player == LocalPlayer or not espDrawings[player] or not hrp or not humanoid or humanoid.Health <= 0 then
			hideDrawingsForPlayer(player)
			continue
		end

		local drawings = espDrawings[player]
		local color = (State.TeamCheck and player.Team == LocalPlayer.Team) and ESP_CONFIG.AllyColor or ESP_CONFIG.EnemyColor
		if State.RainbowMode then color = ESP_CONFIG.RainbowColor end

		local distance = (hrp.Position - Camera.CFrame.Position).Magnitude
		local screenPos, onScreen = Camera:WorldToScreenPoint(hrp.Position)

		if not onScreen or distance > ESP_CONFIG.MaxDistance or (State.TeamCheck and not State.ShowTeam and player.Team == LocalPlayer.Team) then
			hideDrawingsForPlayer(player)
			continue
		end

		local size = char:GetExtentsSize()
		local screenHeight = math.abs((Camera:WorldToScreenPoint((hrp.CFrame * CFrame.new(0, size.Y/2, 0)).Position)).Y - (Camera:WorldToScreenPoint((hrp.CFrame * CFrame.new(0, -size.Y/2, 0)).Position)).Y)
		local screenWidth = screenHeight * 0.75
		local topLeft = Vector2.new(screenPos.X - screenWidth/2, screenPos.Y - screenHeight/2)

		if State.ChamsESP then
			drawings.Highlight.Parent = char
			drawings.Highlight.Enabled = true
			drawings.Highlight.FillColor = ESP_CONFIG.ChamsFillColor
			drawings.Highlight.OutlineColor = ESP_CONFIG.ChamsOutlineColor
			drawings.Highlight.FillTransparency = ESP_CONFIG.ChamsFillTransparency
			drawings.Highlight.OutlineTransparency = ESP_CONFIG.ChamsOutlineTransparency
			drawings.Highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		elseif drawings.Highlight.Parent then
			drawings.Highlight.Enabled = false
		end

		drawings.Name.Visible = State.NameESP
		drawings.Distance.Visible = State.DistanceESP
		if State.NameESP or State.DistanceESP then
			local infoText = ""
			if State.NameESP then infoText = player.DisplayName end
			if State.DistanceESP then infoText = infoText .. " [" .. math.floor(distance) .. "m]" end
			drawings.Name.Text = infoText
			drawings.Name.TextSize = ESP_CONFIG.TextSize
			drawings.Name.Position = UDim2.fromOffset(topLeft.X + screenWidth/2, topLeft.Y - ESP_CONFIG.TextSize - 2)
			drawings.Name.TextColor3 = color
		end

		drawings.HealthBar.Back.Visible = State.HealthESP
		if State.HealthESP then
			local healthPercent = humanoid.Health / humanoid.MaxHealth
			drawings.HealthBar.Back.Position = UDim2.fromOffset(topLeft.X - 7, topLeft.Y)
			drawings.HealthBar.Back.Size = UDim2.fromOffset(4, screenHeight)
			drawings.HealthBar.Front.Size = UDim2.new(1, 0, healthPercent, 0)
			drawings.HealthBar.Front.Position = UDim2.new(0, 0, 1 - healthPercent, 0)
			drawings.HealthBar.Front.BackgroundColor3 = Color3.fromHSV(0.33 * healthPercent, 1, 1)
		end

		drawings.Tracer.Visible = State.TracerESP
		if State.TracerESP then
			local origin
			local originStyle = ESP_CONFIG.TracerOrigins[tracerOriginIndex]
			if originStyle == "Bottom" then origin = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
			elseif originStyle == "Top" then origin = Vector2.new(Camera.ViewportSize.X/2, 0)
			elseif originStyle == "Mouse" then origin = UserInputService:GetMouseLocation()
			else origin = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2) end
			updateLine(drawings.Tracer, origin, Vector2.new(screenPos.X, screenPos.Y), ESP_CONFIG.TracerThickness, color)
		end

		for i, line in ipairs(drawings.Box) do line.Visible = false end
		if State.BoxESP then
			local boxStyle = ESP_CONFIG.BoxStyles[boxStyleIndex]
			if boxStyle == "3D" then
				local corners = {
					hrp.CFrame * CFrame.new(-size.X/2, -size.Y/2, -size.Z/2), hrp.CFrame * CFrame.new(size.X/2, -size.Y/2, -size.Z/2),
					hrp.CFrame * CFrame.new(size.X/2, size.Y/2, -size.Z/2), hrp.CFrame * CFrame.new(-size.X/2, size.Y/2, -size.Z/2),
					hrp.CFrame * CFrame.new(-size.X/2, -size.Y/2, size.Z/2), hrp.CFrame * CFrame.new(size.X/2, -size.Y/2, size.Z/2),
					hrp.CFrame * CFrame.new(size.X/2, size.Y/2, size.Z/2), hrp.CFrame * CFrame.new(-size.X/2, size.Y/2, size.Z/2)
				}
				local points, valid = {}, true
				for i, corner in ipairs(corners) do
					local p, v = Camera:WorldToScreenPoint(corner.Position)
					if not v then valid = false; break end
					points[i] = Vector2.new(p.X, p.Y)
				end
				if valid then
					local connections = {
						1,2, 2,3, 3,4, 4,1, 5,6, 6,7, 7,8, 8,5, 1,5, 2,6, 3,7, 4,8
					}
					for i=1, 12 do
						updateLine(drawings.Box[i], points[connections[i*2-1]], points[connections[i*2]], ESP_CONFIG.BoxThickness, color)
					end
				end
			elseif boxStyle == "Corner" then
				local cornerLength = math.min(screenWidth, screenHeight) * 0.2
				local corners = {
					{topLeft, topLeft + Vector2.new(cornerLength, 0)}, {topLeft, topLeft + Vector2.new(0, cornerLength)},
					{topLeft + Vector2.new(screenWidth, 0), topLeft + Vector2.new(screenWidth - cornerLength, 0)}, {topLeft + Vector2.new(screenWidth, 0), topLeft + Vector2.new(screenWidth, cornerLength)},
					{topLeft + Vector2.new(0, screenHeight), topLeft + Vector2.new(cornerLength, screenHeight)}, {topLeft + Vector2.new(0, screenHeight), topLeft + Vector2.new(0, screenHeight - cornerLength)},
					{topLeft + Vector2.new(screenWidth, screenHeight), topLeft + Vector2.new(screenWidth - cornerLength, screenHeight)}, {topLeft + Vector2.new(screenWidth, screenHeight), topLeft + Vector2.new(screenWidth, screenHeight - cornerLength)}
				}
				for i, data in ipairs(corners) do updateLine(drawings.Box[i], data[1], data[2], ESP_CONFIG.BoxThickness, color) end
			else
				local points = {topLeft, topLeft+Vector2.new(screenWidth,0), topLeft+Vector2.new(screenWidth, screenHeight), topLeft+Vector2.new(0, screenHeight)}
				for i=1,4 do updateLine(drawings.Box[i], points[i], points[i%4+1], ESP_CONFIG.BoxThickness, color) end
			end
		end

		for i, line in ipairs(drawings.Skeleton) do line.Visible = false end
		if State.SkeletonESP then
			local parts = {}
			for _, partName in ipairs({"Head","UpperTorso","LowerTorso","LeftUpperArm","LeftLowerArm","LeftHand","RightUpperArm","RightLowerArm","RightHand","LeftUpperLeg","LeftLowerLeg","LeftFoot","RightUpperLeg","RightLowerLeg","RightFoot"}) do
				parts[partName] = char:FindFirstChild(partName)
			end
			for i, bone in ipairs(BONES) do
				local p1, p2 = parts[bone[1]], parts[bone[2]]
				if p1 and p2 then
					local s1, v1 = Camera:WorldToScreenPoint(p1.Position)
					local s2, v2 = Camera:WorldToScreenPoint(p2.Position)
                    if v1 and v2 then
					    updateLine(drawings.Skeleton[i], Vector2.new(s1.X,s1.Y), Vector2.new(s2.X,s2.Y), ESP_CONFIG.SkeletonThickness, ESP_CONFIG.SkeletonColor)
                    end
				end
			end
		end
	end
end

local function updateAimbotFOV() if not aimbotFovCircle then return end aimbotFovCircle.Visible = State.IsAimbotActive if State.IsAimbotActive then local mousePos = UserInputService:GetMouseLocation() aimbotFovCircle.Position = UDim2.fromOffset(mousePos.X, mousePos.Y) local fovSize = CONFIG.AimbotFOV * 2 aimbotFovCircle.Size = UDim2.fromOffset(fovSize, fovSize) end end
local function getClosestPlayerToMouse() local closestTarget, smallestDistance = nil, CONFIG.AimbotFOV local mousePosition = UserInputService:GetMouseLocation() for _, player in ipairs(Players:GetPlayers()) do local char = player.Character if player ~= LocalPlayer and char and char:FindFirstChild(CONFIG.TargetPartName) and char:FindFirstChildOfClass("Humanoid") and char.Humanoid.Health > 0 then local targetPart = char[CONFIG.TargetPartName] local screenPosition, onScreen = Camera:WorldToScreenPoint(targetPart.Position) if onScreen then local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - mousePosition).Magnitude if distance < smallestDistance then smallestDistance, closestTarget = distance, targetPart end end end end return closestTarget end
local function updateAimbot() if not State.IsAimbotActive then return end local target = getClosestPlayerToMouse() if target then local predictedPosition = target.Position + (target.AssemblyLinearVelocity * CONFIG.AimbotPrediction) local newCFrame = CFrame.new(Camera.CFrame.Position, predictedPosition) if CONFIG.AimbotHardLock then Camera.CFrame = newCFrame else Camera.CFrame = Camera.CFrame:Lerp(newCFrame, CONFIG.AimbotSmoothing) end end end
local function updateFly() local char = LocalPlayer.Character if not State.IsFlyEnabled or not char or not char:FindFirstChild("HumanoidRootPart") then if flyVelocity then flyVelocity:Destroy(); flyVelocity = nil end return end local hrp = char.HumanoidRootPart if not flyVelocity then flyVelocity = Instance.new("LinearVelocity", hrp) flyVelocity.MaxForce = math.huge flyVelocity.Attachment0 = hrp:FindFirstChildWhichIsA("Attachment") or Instance.new("Attachment", hrp) flyVelocity.RelativeTo = Enum.ActuatorRelativeTo.World end local moveVector = Vector3.new() if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVector += Camera.CFrame.LookVector end if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVector -= Camera.CFrame.LookVector end if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVector += Camera.CFrame.RightVector end if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVector -= Camera.CFrame.RightVector end if UserInputService:IsKeyDown(CONFIG.FlyUpKey) then moveVector += Vector3.new(0, 1, 0) end if UserInputService:IsKeyDown(CONFIG.FlyDownKey) then moveVector -= Vector3.new(0, 1, 0) end flyVelocity.VectorVelocity = moveVector.Magnitude > 0 and moveVector.Unit * CONFIG.FlySpeed or Vector3.zero end
local function teleportToCursor() if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end local mouseLocation = UserInputService:GetMouseLocation() local unitRay = Camera:ViewportPointToRay(mouseLocation.X, mouseLocation.Y) local rayParams = RaycastParams.new() rayParams.FilterDescendantsInstances = {LocalPlayer.Character} rayParams.FilterType = Enum.RaycastFilterType.Exclude local result = Workspace:Raycast(unitRay.Origin, unitRay.Direction * CONFIG.TeleportMaxDistance, rayParams) local targetPos = result and result.Position or (unitRay.Origin + unitRay.Direction * CONFIG.TeleportMaxDistance) LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos) end

local gui, mainFrame
local function toggleState(stateKey, button)
	State[stateKey] = not State[stateKey]
	button.Text = button.Name .. ": " .. (State[stateKey] and "ON" or "OFF")
	button.TextColor3 = State[stateKey] and Color3.fromRGB(0, 255, 127) or Color3.fromRGB(255, 70, 70)
	if stateKey == "IsFlyEnabled" and not State[stateKey] and flyVelocity then flyVelocity:Destroy(); flyVelocity = nil end
	if stateKey == "IsWallBangEnabled" then updateWorkspaceCollision(State[stateKey]) end
end

local function createGUI()
	gui = Instance.new("ScreenGui")
	gui.Name = "UtilitySuiteGUI"
	gui.ResetOnSpawn = false
	gui.DisplayOrder = 999

	espContainer = Instance.new("Frame", gui)
	espContainer.Name = "ESPContainer"
	espContainer.Size = UDim2.new(1, 0, 1, 0)
	espContainer.BackgroundTransparency = 1

	local aimbotContainer = Instance.new("Frame", gui)
	aimbotContainer.Name = "AimbotContainer"
	aimbotContainer.Size = UDim2.new(1, 0, 1, 0)
	aimbotContainer.BackgroundTransparency = 1

	aimbotFovCircle = Instance.new("Frame", aimbotContainer)
	aimbotFovCircle.Name = "AimbotFovCircle"
	aimbotFovCircle.AnchorPoint = Vector2.new(0.5, 0.5)
	aimbotFovCircle.BackgroundTransparency = 1
	aimbotFovCircle.BorderColor3 = Color3.fromRGB(170, 0, 255)
	aimbotFovCircle.BorderSizePixel = 2
	aimbotFovCircle.Visible = false
	local circleCorner = Instance.new("UICorner", aimbotFovCircle)
	circleCorner.CornerRadius = UDim.new(1, 0)

	mainFrame = Instance.new("Frame", gui)
	mainFrame.Size = UDim2.fromOffset(250, 480)
	mainFrame.Position = UDim2.new(0, 20, 0.5, -240)
	mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	mainFrame.BorderSizePixel = 0
	Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8)

	local title = Instance.new("TextLabel", mainFrame)
	title.Size = UDim2.new(1, 0, 0, 40)
	title.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	title.Text = "mooncat v5.0 (FIXED)"
	title.TextSize = 24
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.Font = Enum.Font.SourceSansBold
	Instance.new("UICorner", title).CornerRadius = UDim.new(0, 8)

	local scrollingFrame = Instance.new("ScrollingFrame", mainFrame)
	scrollingFrame.Position = UDim2.new(0, 0, 0, 40)
	scrollingFrame.Size = UDim2.new(1, 0, 1, -40)
	scrollingFrame.BackgroundTransparency = 1
	scrollingFrame.BorderSizePixel = 0
	scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	scrollingFrame.ScrollBarImageColor3 = Color3.fromRGB(170, 0, 255)
	scrollingFrame.ScrollBarThickness = 8

	local listLayout = Instance.new("UIListLayout", scrollingFrame)
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	listLayout.Padding = UDim.new(0, 10)

	local padding = Instance.new("UIPadding", scrollingFrame)
	padding.PaddingTop = UDim.new(0, 15)
	padding.PaddingLeft = UDim.new(0, 10)
	padding.PaddingRight = UDim.new(0, 10)

	listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function() scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + padding.PaddingTop.Offset) end)

	local function createCategory(text) local label = Instance.new("TextLabel", scrollingFrame) label.Name = text .. "Category" label.LayoutOrder = #scrollingFrame:GetChildren() label.Size = UDim2.new(1, 0, 0, 25) label.BackgroundTransparency = 1 label.Font = Enum.Font.SourceSansBold label.Text = text label.TextColor3 = Color3.new(1,1,1) label.TextSize = 20 label.TextXAlignment = Enum.TextXAlignment.Left return label end
	local function createToggle(text, stateKey) local button = Instance.new("TextButton", scrollingFrame) button.Name = text button.LayoutOrder = #scrollingFrame:GetChildren() button.Size = UDim2.new(1, 0, 0, 30) button.BackgroundColor3 = Color3.fromRGB(60, 60, 60) button.Font = Enum.Font.SourceSans button.Text = text .. ": " .. (State[stateKey] and "ON" or "OFF") button.TextSize = 20 button.TextColor3 = State[stateKey] and Color3.fromRGB(0, 255, 127) or Color3.fromRGB(255, 70, 70) Instance.new("UICorner", button).CornerRadius = UDim.new(0, 4) uiElements[stateKey] = button local connection = button.MouseButton1Click:Connect(function() toggleState(stateKey, button) end) return button, connection end
	local function createSlider(name, configKey, maxConfigKey, format, customUpdateFunc) local container = Instance.new("Frame", scrollingFrame) container.BackgroundTransparency = 1 container.LayoutOrder = #scrollingFrame:GetChildren() container.Size = UDim2.new(1, 0, 0, 40) local list = Instance.new("UIListLayout", container) list.Padding = UDim.new(0, 2) local label = Instance.new("TextLabel", container) label.Size = UDim2.new(1, 0, 0, 18) label.BackgroundTransparency = 1 label.TextColor3 = Color3.fromRGB(255, 255, 255) label.Font = Enum.Font.SourceSans label.TextSize = 18 label.TextXAlignment = Enum.TextXAlignment.Left local slider = Instance.new("Frame", container) slider.Size = UDim2.new(1, 0, 0, 12) slider.BackgroundColor3 = Color3.fromRGB(60, 60, 60) Instance.new("UICorner", slider).CornerRadius = UDim.new(0, 6) local bar = Instance.new("Frame", slider) bar.BackgroundColor3 = Color3.fromRGB(170, 0, 255) Instance.new("UICorner", bar).CornerRadius = UDim.new(0, 6) local function updateVisuals() local value = CONFIG[configKey] or ESP_CONFIG[configKey] or 1 local maxValue = CONFIG[maxConfigKey] or ESP_CONFIG[maxConfigKey] or maxConfigKey or 1 label.Text = name .. ": " .. string.format(format, value) bar.Size = UDim2.new(math.clamp(value / maxValue, 0, 1), 0, 1, 0) end slider.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then local function updateValue(mouseInput) local relativeX = math.clamp(mouseInput.Position.X - slider.AbsolutePosition.X, 0, slider.AbsoluteSize.X) local percentage = relativeX / slider.AbsoluteSize.X local maxVal = CONFIG[maxConfigKey] or ESP_CONFIG[maxConfigKey] or maxConfigKey or 1 local calculatedValue = percentage * maxVal if CONFIG[configKey] then CONFIG[configKey] = calculatedValue else ESP_CONFIG[configKey] = calculatedValue end updateVisuals() if customUpdateFunc then customUpdateFunc() end end updateValue(input) local moveConn, releaseConn moveConn = UserInputService.InputChanged:Connect(function(mi) if mi.UserInputType == Enum.UserInputType.MouseMovement then updateValue(mi) end end) releaseConn = UserInputService.InputEnded:Connect(function(ei) if ei.UserInputType == Enum.UserInputType.MouseButton1 then moveConn:Disconnect(); releaseConn:Disconnect() end end) end end) updateVisuals() end

	createCategory("ESP")
	createToggle("Enable ESP", "ESP_Enabled")
	createToggle("Box ESP", "BoxESP")
	local boxStyleButton = Instance.new("TextButton", scrollingFrame) boxStyleButton.Name = "Box Style" boxStyleButton.LayoutOrder = #scrollingFrame:GetChildren() boxStyleButton.Size = UDim2.new(1, 0, 0, 30) boxStyleButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60) boxStyleButton.Font = Enum.Font.SourceSans boxStyleButton.Text = "Style: " .. ESP_CONFIG.BoxStyles[boxStyleIndex] boxStyleButton.TextSize = 20 boxStyleButton.TextColor3 = Color3.fromRGB(220, 220, 220) Instance.new("UICorner", boxStyleButton).CornerRadius = UDim.new(0, 4) boxStyleButton.MouseButton1Click:Connect(function() boxStyleIndex = (boxStyleIndex % #ESP_CONFIG.BoxStyles) + 1 boxStyleButton.Text = "Style: " .. ESP_CONFIG.BoxStyles[boxStyleIndex] end)
	createToggle("Tracer ESP", "TracerESP")
	local tracerOriginButton = Instance.new("TextButton", scrollingFrame) tracerOriginButton.Name = "Tracer Origin" tracerOriginButton.LayoutOrder = #scrollingFrame:GetChildren() tracerOriginButton.Size = UDim2.new(1, 0, 0, 30) tracerOriginButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60) tracerOriginButton.Font = Enum.Font.SourceSans tracerOriginButton.Text = "Origin: " .. ESP_CONFIG.TracerOrigins[tracerOriginIndex] tracerOriginButton.TextSize = 20 tracerOriginButton.TextColor3 = Color3.fromRGB(220, 220, 220) Instance.new("UICorner", tracerOriginButton).CornerRadius = UDim.new(0, 4) tracerOriginButton.MouseButton1Click:Connect(function() tracerOriginIndex = (tracerOriginIndex % #ESP_CONFIG.TracerOrigins) + 1 tracerOriginButton.Text = "Origin: " .. ESP_CONFIG.TracerOrigins[tracerOriginIndex] end)
	createToggle("Name ESP", "NameESP")
	createToggle("Health ESP", "HealthESP")
	createToggle("Distance ESP", "DistanceESP")
	createToggle("Skeleton ESP", "SkeletonESP")
	createToggle("Chams ESP", "ChamsESP")
	createToggle("Rainbow Mode", "RainbowMode")
	createSlider("Max Distance", "MaxDistance", 5000, "%.0fm")

	createCategory("Combat")
	createToggle("Hitbox Expander", "HitboxESP")
	createSlider("Hitbox Size", "HitboxSize", "MaxHitboxSize", "%.1f")
	
	local modifyRpgButton = Instance.new("TextButton", scrollingFrame)
	modifyRpgButton.Name = "[MOD] Make RPG OP"
	modifyRpgButton.LayoutOrder = #scrollingFrame:GetChildren()
	modifyRpgButton.Size = UDim2.new(1, 0, 0, 30)
	modifyRpgButton.BackgroundColor3 = Color3.fromRGB(100, 60, 200) -- Purple color
	modifyRpgButton.Font = Enum.Font.SourceSansBold
	modifyRpgButton.Text = "[MOD] Make RPG OP"
	modifyRpgButton.TextSize = 18
	modifyRpgButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	Instance.new("UICorner", modifyRpgButton).CornerRadius = UDim.new(0, 4)
	modifyRpgButton.MouseButton1Click:Connect(modifyRpgSettings)
	
	local killAllButton = Instance.new("TextButton", scrollingFrame) 
	killAllButton.Name = "Kill All (ACS)" 
	killAllButton.LayoutOrder = #scrollingFrame:GetChildren() 
	killAllButton.Size = UDim2.new(1, 0, 0, 30) 
	killAllButton.BackgroundColor3 = Color3.fromRGB(150, 40, 40) 
	killAllButton.Font = Enum.Font.SourceSansBold 
	killAllButton.Text = "Kill All (ACS)" 
	killAllButton.TextSize = 20 
	killAllButton.TextColor3 = Color3.fromRGB(255, 255, 255) 
	Instance.new("UICorner", killAllButton).CornerRadius = UDim.new(0, 4) 
	killAllButton.MouseButton1Click:Connect(killAllPlayers)
	
	local targetButton = Instance.new("TextButton", scrollingFrame) targetButton.Name = "Aimbot Target" targetButton.LayoutOrder = #scrollingFrame:GetChildren() targetButton.Size = UDim2.new(1, 0, 0, 30) targetButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60) targetButton.Font = Enum.Font.SourceSans targetButton.Text = "Target: " .. CONFIG.TargetPartName targetButton.TextSize = 20 targetButton.TextColor3 = Color3.fromRGB(220, 220, 220) Instance.new("UICorner", targetButton).CornerRadius = UDim.new(0, 4) targetButton.MouseButton1Click:Connect(function() aimbotTargetIndex = (aimbotTargetIndex % #CONFIG.AimbotTargetParts) + 1 CONFIG.TargetPartName = CONFIG.AimbotTargetParts[aimbotTargetIndex] targetButton.Text = "Target: " .. CONFIG.TargetPartName end)
	createSlider("Aimbot FOV", "AimbotFOV", "MaxAimbotFOV", "%.0f")
	createSlider("Aimbot Prediction", "AimbotPrediction", "MaxAimbotPrediction", "%.2f")
	createSlider("Aimbot Smoothing", "AimbotSmoothing", "MaxAimbotSmoothing", "%.2f")

	createCategory("Movement")
	createToggle("Fly", "IsFlyEnabled")
	createToggle("WallBang (Noclip)", "IsWallBangEnabled")
	createSlider("WalkSpeed", "DefaultWalkSpeed", "MaxWalkSpeed", "%.0f", function() if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then LocalPlayer.Character.Humanoid.WalkSpeed = CONFIG.DefaultWalkSpeed end end)
	createSlider("Fly Speed", "FlySpeed", "MaxFlySpeed", "%.0f")

	gui.Parent = LocalPlayer:WaitForChild("PlayerGui")
	log("[‚úÖ]", "GUI created and parented successfully.")
end

local isGuiVisible = true
function toggleGUI() isGuiVisible = not isGuiVisible local goalPosition = isGuiVisible and UDim2.new(0, 20, 0.5, -mainFrame.AbsoluteSize.Y / 2) or UDim2.new(0, -mainFrame.AbsoluteSize.X - 20, 0.5, -mainFrame.AbsoluteSize.Y / 2) mainFrame:TweenPosition(goalPosition, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.3, true) end

local function onCharacterAdded(character)
	task.wait(0.1)
	if not character or not character.Parent then return end
	local humanoid = character:WaitForChild("Humanoid")
	humanoid.WalkSpeed = CONFIG.DefaultWalkSpeed
end
local function onPlayerAdded(player) if player ~= LocalPlayer then createEspForPlayer(player) end end
local function onPlayerRemoving(player) removeEspForPlayer(player) if originalHitboxSizes[player] then originalHitboxSizes[player] = nil end end
local function onInputBegan(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == CONFIG.ToggleGUIKey then toggleGUI() end
	if input.KeyCode == CONFIG.AimbotKey then State.IsAimbotActive = true end
	if input.KeyCode == CONFIG.TeleportKey then teleportToCursor() end
	if input.KeyCode == CONFIG.ToggleESPKey then if uiElements["ESP_Enabled"] then toggleState("ESP_Enabled", uiElements["ESP_Enabled"]) end end
end
local function onInputEnded(input) if input.KeyCode == CONFIG.AimbotKey then State.IsAimbotActive = false end end

-- [+] INITIALIZATION [+]
createGUI()
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)
UserInputService.InputBegan:Connect(onInputBegan)
UserInputService.InputEnded:Connect(onInputEnded)
if LocalPlayer.Character then onCharacterAdded(LocalPlayer.Character) end
LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

for _, player in ipairs(Players:GetPlayers()) do onPlayerAdded(player) end

RunService.RenderStepped:Connect(function()
	updateAllEsp()
	updateAimbot()
	updateAimbotFOV()
	updateFly()
	updateHitboxes()
end)

log("[‚úÖ]", "All events connected and main loop started.")

print([[
 __  __                      ____      _
|  \/  | ___   ___  _ __    / ___|__ _| |_
| |\/| |/ _ \ / _ \| '_ \  | |   / _` | __|
| |  | | (_) | (_) | | | | | |__| (_| | |_
|_|  |_|\___/ \___/|_| |_|  \____\__,_|\__|

mooncat v5.0 (FIXED) (Client-Side) Loaded. Press RightShift to toggle the menu.
RPG Modifier has been patched and is now more reliable.
]])
